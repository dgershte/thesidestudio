<html style="font-family: Verdana, Geneva, sans-serif;"><head><script type="text/javascript" src="js/jquery.js"></script><script type="text/javascript" src="js/home.js"></script><link rel="stylesheet" href="home.css" type="text/css"/><title>CS488 Report</title><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=m0tazYRimFnV1hoGKbgtnw');ol{margin:0;padding:0}.c22{vertical-align:top;width:112.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c21{vertical-align:top;width:99pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c24{vertical-align:top;width:122.2pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c23{vertical-align:top;width:121.5pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c27{list-style-type:decimal;margin:0;padding:0}.c16{list-style-type:circle;margin:0;padding:0}.c20{list-style-type:disc;margin:0;padding:0}.c5{padding-left:0pt;direction:ltr;margin-left:72pt}.c30{max-width:468pt;background-color:#ffffff;margin:auto;padding:72pt 72pt 72pt 72pt}.c1{direction:ltr;margin-left:36pt}.c3{height:11pt;direction:ltr}.c6{text-indent:36pt;direction:ltr}.c15{color:inherit;text-decoration:inherit}.c26{font-size:30pt}.c12{height:11pt}.c17{margin-left:72pt}.c11{font-size:8pt}.c4{text-align:center}.c25{border-collapse:collapse}.c10{direction:ltr}.c14{padding-left:0pt}.c9{text-indent:36pt}.c29{font-size:12pt}.c8{font-weight:bold}.c18{line-height:1.0}.c2{text-decoration:underline}.c13{font-size:18pt}.c0{font-family:"Cambria"}.c28{margin-left:108pt}.c7{font-size:9pt}.c19{font-size:14pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style><script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js"></script></head><body><div id="header"><script>loadMenu()</script></div><div id="container"><div class="c30"><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c4 c10"><span class="c8 c0 c26">Ray Tracer</span></p><p class="c3 c4"><span class="c8 c0 c13"></span></p><p class="c4 c10"><span class="c0">Dalya Gershtein</span></p><p class="c4 c10"><span class="c0">20341368</span></p><p class="c4 c10"><span class="c0">CS488</span></p><p class="c4 c10"><span class="c0">July 24th, 2012</span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><p class="c3 c4"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c8 c0 c19">1 Purpose<br></span><span class="c0 c29">Extend the functionality of the Ray Tracer from Assignment 4 to create highly photo-realistic images.</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c8 c0">1.1 Topics</span></p><ol class="c16" start="1"><li class="c5"><span class="c0">Raytracer improvements in speed and quality</span></li><li class="c5"><span class="c0">Additional primitives for modeling enhancement. Primitives are much faster to render, since determining the point of intersection is significantly simpler than meshes.</span></li><li class="c5"><span class="c0">Advanced lighting effects. Point lights only create hard shadows. To achieve a more realistic soft shadow effect, use spherical area lights with a user defined radius to capture the realistic umbra and penumbra of an object&#39;s shadow.</span></li><li class="c5"><span class="c0">Additional material options, including UV mapping for meshes and primitives. In order for primitives to have a more realistic looking material, source images can be mapped as textures to spheres, cubes and meshes.</span></li></ol><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c8 c0">1.2 &nbsp;Statement</span></p><p class="c1"><span class="c0">I chose to create a Ray Tracer for my final project because I hope to one day have a career in 3D Computer Graphics or Computer Animation. For several years now I have been creating 3D models in Maya and using Mental Ray to ray trace the scene after adding lighting, shading, materials, texture mapping and various other effects. The more scenes I ray traced and the more effects I discovered, the more interested I became in what was going on behind the scenes during ray tracing.</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To demonstrate the additional functionality of the extended ray tracer, I decided to create a scene with a model of the robot character Wall-E, from the Pixar movie Wall-E. Wall-E is positioned on a planet full of garbage cubes, with planet and stars in the background.</span></p><p class="c3"><span class="c0"></span></p><ol class="c16" start="1"><li class="c5"><span class="c0">The Wall-E model was created using a combination of exported obj files that I modeled in Autodesk Maya, and extra primitives that I added to the original raytracer. I used cylinders to create the hands and neck. I modeled the tires and eyes in Maya, split the meshes into triangles, and exported them as obj files.</span></li><li class="c5"><span class="c0">Once the model and scene were created in Maya, I exported the unwrapped UV map as an image so I could generate realistic textures corresponding to the proper coordinates. Using these UV maps, I created a cube texture for Wall-E&#39;s body, as well as textures for his tires and eyes in Adobe Photoshop. I also created a normal map for the tires, water, and garbage cubes. In order for the textures and normal textures to map to the meshes properly, I had to modify the LUA-based file to accept UV points as well as vertices and faces when creating a mesh.</span></li><li class="c5"><span class="c0">For the textures to map to the meshes and primitives correctly, I implemented UV-texture mapping for spheres, cubes and meshes.</span></li><li class="c5"><span class="c0">To simulate the bump effect in the tires and garbage cubes while keeping a low polygon count, I implemented normal mapping.</span></li><li class="c5"><span class="c0">To simulate the metallic look on Wall-E&#39;s arms and neck, I added an extra parameter to the material call in LUA, which takes in the coefficient of glossiness the material will have. This creates a glossy metal feel.</span></li><li class="c5"><span class="c0">I added a reflection coefficient to the material parameters in order for Wall-E&#39;s eyes to have the reflection of planets, water and surroundings.</span></li><li class="c5"><span class="c0">The starry night background was created using cube environment mapping.</span></li><li class="c5"><span class="c0">To eliminate jagged edges in the final scene, I implemented adaptive anti aliasing.</span></li></ol><p class="c3"><span class="c0"></span></p><p class="c1"><span class="c0">I believe this is a fairly interesting scene, that combines and demonstrates a lot of the special effects of the extended ray tracer. I added two extra objectives since I changed my final scene after the proposal and wanted to create the desired effects for the new scene, which were not part of the original objectives.</span></p><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c8 c0">1.4 Milestones</span></p><p class="c6"><span class="c0">I implemented the objectives in the following order:</span></p><ol class="c16" start="1"><li class="c5"><span class="c2 c0">Reflection<br></span><span class="c0">I had already implemented most of the reflection code for Assignment 4, but it was not fully working at the time. This was an easy fix so I decided to get it out of the way first.</span></li><li class="c5"><span class="c2 c0">Extra Primitives</span><span class="c0"><br></span><span class="c0">I decided to start with the easy objective first. For my scene I only needed one extra primitive - cylinder - so I extended the LUA-based language to accept non-hierarchical and hierarchical cylinder and cone primitives.</span></li><li class="c5"><span class="c2 c0">Depth of Field<br></span><span class="c0">This also proved to be an easy objective, since all I had to modify was shooting a higher number of rays for each pixel, and adding calculating the distortion.</span></li><li class="c5"><span class="c2 c0">Refraction<br></span><span class="c0">I originally thought this would be as simple and quick to implement as refraction, but after spending three days on it, it proved to be one of the harder objectives.</span></li><li class="c5"><span class="c2 c0">Soft Shadows</span></li><li class="c5"><span class="c2 c0">Glossy Reflection</span><span class="c0"><br></span><span class="c0">Once I had reflection and soft shadows working, glossy reflection was an easy objective since I already knew how to calculate the reflected rays, and used a similar technique as I used for soft shadows to generate x number of randomized rays that were then averaged out.</span></li><li class="c5"><span class="c2 c0">Anti-Aliasing<br></span><span class="c0">For Assignment 4, I implemented super sampling, so modifying the code to Anti-Aliasing proved to be fairly simple.</span></li><li class="c5"><span class="c2 c0">Grid Space Subdivision</span><span class="c0"><br>This was the hardest objective in my opinion, so I pushed it back to make sure I get enough objectives done before starting on it. I did not need to render very complicated scenes, so algorithm improvement was not a very big priority to me.</span></li><li class="c5"><span class="c2 c0">Texture Mapping</span></li><li class="c5"><span class="c2 c0">Environment Mapping<br></span><span class="c0">This was an extra objective. Once I figured out how to implement texture mapping for cubes, I realized environment mapping uses the same technique and it would be very simple&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to add to the scene.</span></li><li class="c5"><span class="c0 c2">Normal Mapping<br></span><span class="c0">Also an extra objective. Once I had texture mapping working, I really wanted to create the bump effect in Wall-E&#39;s tires, so I implemented normal mapping.</span></li></ol><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c2 c0">1.5 Personal Organization and Coding Method</span></p><ol class="c16" start="1"><li class="c5"><span class="c0">Vim: For coding</span></li><li class="c5"><span class="c0">Mercurial: for source code version control</span></li><li class="c5"><span class="c0">GDB: for debugging</span></li><li class="c5"><span class="c0">Graphics Lab machines: for running the raytracer</span></li><li class="c5"><span class="c0">Autodesk Maya: for creating the models</span></li><li class="c5"><span class="c0">Houdini: for exporting UV coordinates</span></li><li class="c5"><span class="c0">Adobe Photoshop: for creating textures</span></li></ol><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c8 c0 c19">2 Project Manual</span></p><p class="c3"><span class="c8 c0 c19"></span></p><p class="c10"><span class="c0">The advanced raytracer is used much like the original ray tracer, but with more command line options, and extended LUA options. The following shell command is used to run the program with the specified lua file:</span></p><p class="c6"><span class="c0">./rt scene.lua </span></p><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c8 c0">2.1 Using the Raytracer</span></p><p class="c6"><span class="c0">Optional command line parameters:</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-ss : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Super Sample</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">Enable super sampling for enhanced image quality.</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-aa : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adaptive Anti Aliasing</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable adaptive super sampling for more efficient enhanced image quality.</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">-reflection : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflection </span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable reflective materials to render with reflection.</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span><span class="c0">-envmap : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Environment Mapping </span></p><p class="c10 c28"><span class="c0">Enable environment map. The texture image is automatically set to &#39;textures/background.png&#39;. To change the image of the environment, change the filename to background.png and place it in the textures folder. </span></p><p class="c3"><span class="c0"></span></p><p class="c3 c9"><span class="c8 c0"></span></p><p class="c3 c9"><span class="c8 c0"></span></p><p class="c3 c9"><span class="c8 c0"></span></p><p class="c3 c9"><span class="c8 c0"></span></p><p class="c6"><span class="c8 c0">2.2 Communication</span></p><p class="c6"><span class="c0">The basic flow of information is as follows:</span></p><p class="c6"><span class="c2 c0">Input: </span></p><ol class="c16" start="1"><li class="c5"><span class="c0">A LUA file describing a scene to render. This file can contain imported .OBJ files as well as .PNG files.</span></li></ol><p class="c6"><span class="c2 c0">Interaction: </span></p><p class="c1"><span class="c0">There is no user interaction in this project apart from the initial user input into the raytracer. The only interaction is the output of the percent of progress generated by the raytracer, relative to the number of pixels.</span></p><p class="c6"><span class="c2 c0">Output: </span></p><p class="c6"><span class="c0">The resulting image will be created under the specified name in the LUA file.</span></p><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c8 c0">2.3 Extensions to LUA</span></p><p class="c1"><span class="c0">The LUA based modelling language was extended from the previous assignment to include and modify the following commands:</span></p><ol class="c16" start="1"><li class="c5"><span class="c0 c7">gr.light( &lt;position&gt;, &lt;colour&gt;, &lt;attenuation&gt;, &lt;area light radius&gt;, &lt;area light flag&gt;)</span><span class="c0"><br></span><span class="c0">Creates a light at the specified position, colour and attenuation. To create an area light for soft shadows, set area light flag to 1, and assign area light radius to a value greater than zero.</span></li><li class="c5"><span class="c0 c7">gr.cylinder( &lt;name&gt; ) </span><span class="c0"><br></span><span class="c0">Creates a cylinder primitive at the origin with a radius of 0.5 and height of 1.</span></li><li class="c5"><span class="c0 c7">gr.cone( &lt;name&gt; )</span><span class="c0"><br>Creates a cone primitive at the origin with a radius of 0.5 ad a height of 1.</span></li><li class="c5"><span class="c0 c7">gr.mesh( &lt;name&gt;, &lt; vertices &gt;, &lt;UV coordinates&gt;, &lt; faces &gt;)</span><span class="c0"><br>Mesh was modified from the previous assignment to accept UV coordinate in order to be able to handle texture mapping and normal mapping.</span></li><li class="c5"><span class="c0 c7">gr.material( &lt;diffuse colour&gt;, &lt;specular colour&gt;, &lt;reflection coefficient, refraction coefficient, refraction index&gt;, &lt;shininess factor&gt;, &lt;glossy reflection factor&gt;)</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Creates a material with the specified diffuse and specular colours. To create a refractive material, the diffuse colour must be set to black, with a </span><span class="c0 c7">refraction coefficient </span><span class="c0">of black and a </span><span class="c0 c7">refraction index</span><span class="c0">&nbsp;between 1.33 and 1.67 for best results. Reflection coefficient takes in a value in the range of 0 and 1.</span></li><li class="c5"><span class="c0 c7">geometry</span><span class="c0 c7">_node:set_texture</span><span class="c0 c7">( &lt;image&gt; ) </span><span class="c0"><br></span><span class="c0">Set a texture to the specified geometry node. Files must be PNG format. The cube primitive expects a texture with six faces.</span></li><li class="c5"><span class="c0 c7">geometry</span><span class="c0 c7">_node:set_normalTexture</span><span class="c0 c7">(&lt;image&gt;)</span><span class="c0"><br>Set a normal map to the specified geometry node.</span></li></ol><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c10"><span class="c8 c0 c19">3 Code Organization</span></p><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c8 c0">3.1 File Structure</span></p><p class="c1"><span class="c0">All project files are stored in directory </span><span class="c0 c7">~/cs488/handin/A5</span><span class="c0">. All </span><span class="c0 c7">*.cpp</span><span class="c0">&nbsp;and </span><span class="c0 c7">*.hpp</span><span class="c0">&nbsp;are located in the </span><span class="c0 c7">src</span><span class="c0">&nbsp;folder.</span></p><p class="c1"><span class="c0">A README file is included in </span><span class="c0 c7">A5/src </span><span class="c0">subdirectory. All the </span><span class="c0 c7">LUA </span><span class="c0">based files are located in the </span><span class="c0 c7">A5/data </span><span class="c0">subdirectory.</span></p><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c8 c0">3.2 Code Map</span></p><ol class="c16" start="1"><li class="c5"><span class="c0 c7">algebra.cpp, algebra.hpp</span><span class="c0 c7"><br></span><span class="c0">Contains the original files provided for A4, as well as some extra Matrix operations I implemented for A4.</span></li><li class="c5"><span class="c0 c11">image.cpp, image.hpp</span><span class="c0"><br></span><span class="c0">Contains the original files provided for A4.</span></li><li class="c5"><span class="c0 c7">light.cpp, light.hpp</span><span class="c0"><br></span><span class="c0">Contains the files provided for A4 with some additional members to the Light class, in particular a light radius and a light type for Area Lights.</span></li><li class="c5"><span class="c0 c7">lua.hpp</span><span class="c0"><br></span><span class="c0">Original unmodified file</span></li><li class="c5"><span class="c0 c7">main.cpp</span><span class="c0"><br></span><span class="c0">Contains parsing and processing of the command line arguments</span></li><li class="c5"><span class="c0 c7">material.cpp, material.hpp</span><span class="c0"><br></span><span class="c0">Contains the original implementation of Material, which was extended to allow for glossy, refractive and reflective materials.</span></li><li class="c5"><span class="c0 c7">mesh.cpp, mesh.hpp</span><span class="c0"><br></span><span class="c0">Contains all the implementation for the mesh class. Code was modified from original version provided for A4 to extend the Mesh class to contain UV coordinates as well as vertices and faces.</span></li><li class="c5"><span class="c0 c7">polyroots.cpp, polyroots.hpp</span><span class="c0"><br></span><span class="c0">Unmodified files that contain the code to calculate roots of a quadratic equation.</span></li><li class="c5"><span class="c0 c7">primitive.cpp, primitive.hpp</span><span class="c0"><br></span><span class="c0">Contains the extended Primitive class to allow for modeling of Cones and Cylinders. All intersection calculations, AABB boxes, and UV maps are implemented in these files for Primitive nodes.</span></li><li class="c5"><span class="c0 c7">ray.cpp, ray.hpp</span><span class="c0"><br></span><span class="c0">Contains the Ray structure which is made up of a ray origin, ray direction, ray ID and a point UV.</span></li><li class="c5"><span class="c0 c7">a4.cpp, a4.hpp</span><span class="c0"><br></span><span class="c0">Contains the main raytracing algorithm. Holds the code for generating most of the objectives.</span></li><li class="c5"><span class="c0 c7">scene.cpp, scene.hpp</span><span class="c0"><br></span><span class="c0">Manages the general hierarchy of Nodes in the Scene. This is where all the hierarchical transformations are stored and used to apply all the necessary transformations on the primitives when doing intersection calculations.</span></li><li class="c5"><span class="c0 c7">environment.cpp, environment.hpp<br></span><span class="c0">Holds the CubeMap structure which creates the environment map for the scene.</span></li></ol><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c8 c0 c19">4 Implementation</span></p><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c8 c0">5.1 Extra Primitives</span></p><p class="c1"><span class="c0">Four extra primitives have been added to the Primitive class: Cone, Cylinder, NonhierCone and NonhierCylinder.</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A cone can be added using the </span><span class="c0 c7">LUA </span><span class="c0">function call</span></p><p class="c4 c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0 c7">gr.cone( &lt;name&gt; ) </span></p><p class="c1"><span class="c0">which creates a right cone at the origin with radius 0.5 and a height of 1. The base of the cone is coincident with the origin. To render the cone properly, I simply had to determine the point of intersection of the ray with the cone, using the following equation</span></p><p class="c6"><span class="c0 c7">Ray Equation:</span></p><p class="c17 c10"><img src="images/image00.png"></p><p class="c17 c10"><img src="images/image01.png"></p><p class="c10 c17"><img src="images/image02.png"></p><p class="c17 c10"><img src="images/image03.png"></p><p class="c17 c10"><img src="images/image04.png"></p><p class="c17 c10"><img src="images/image05.png"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span class="c0">Where </span><img src="images/image06.png"><span class="c0">and </span><img src="images/image07.png"><span class="c0">&nbsp;are ray direction and ray origin, respectively, and </span><img src="images/image08.png"><span class="c0">and </span><img src="images/image09.png"><span class="c0">&nbsp;are height and radius respectively.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarly, a non hierarchical cone can be created using the </span><span class="c0 c7">LUA</span><span class="c0">&nbsp;command</span></p><p class="c4 c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0 c7">gr.nh</span><span class="c0 c7">_cone</span><span class="c0 c7">( &lt;name&gt;, &lt;position&gt;, &lt;radius&gt;, &lt;height&gt; ) </span></p><p class="c1"><span class="c0">which creates a NonhierCone with the specified name at position position, radius radius, and height height. Intersection detection is done the same way as Cone.</span></p><p class="c1 c12"><span class="c0"></span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Cylinder primitive can be created using the LUA command</span></p><p class="c4 c10"><span class="c0 c7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gr.cylinder( &lt;name&gt; )</span></p><p class="c1"><span class="c0">Which creates a right cylinder at the origin with height 1 and radius 0.5. The center of the Cylinder is coincident with the origin. The point of intersection of the ray with the cone was determined using the following equation:</span></p><p class="c6"><span class="c0 c7">Ray Equation:</span></p><p class="c17 c10"><img src="images/image00.png"></p><p class="c17 c10"><img src="images/image10.png"></p><p class="c17 c10"><img src="images/image01.png"></p><p class="c17 c10"><img src="images/image02.png"></p><p class="c17 c10"><img src="images/image11.png"></p><p class="c17 c10"><img src="images/image12.png"></p><p class="c6"><span class="c0">Similarly, a non hierarchical cylinder can be created using the </span><span class="c0 c7">LUA</span><span class="c0">&nbsp;command</span></p><p class="c4 c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0 c7">gr.nh</span><span class="c0 c7">_cylinder</span><span class="c0 c7">( &lt;name&gt;, &lt;position&gt;, &lt;radius&gt;, &lt;height&gt; ) </span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which creates a NonhierCylinder with the specified name at position </span><span class="c0 c7">position</span><span class="c0">, radius </span><span class="c0 c7">radius</span><span class="c0">, and height </span><span class="c0 c7">height</span><span class="c0">. Intersection detection is done the same way as Cylinder.</span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c6"><span class="c8 c0">5.2 Reflection</span></p><p class="c1"><span class="c0">For the final scene, I wanted to have a reflective water material, so show the reflection of planets and Wall-E. A reflective material is created using the following </span><span class="c0 c7">LUA</span><span class="c0">&nbsp;</span><span class="c0">command:</span></p><p class="c1 c4"><span class="c0 c7">gr.material( &lt;diffuse&gt;, &lt;specular&gt;, &lt; reflection coefficient, refraction coefficient, refraction index&gt;, shininess, glossy reflection)</span></p><p class="c1"><span class="c0">To create a mirror reflected material, set the reflection coefficient to a value greater than 0 and less than 1.</span></p><p class="c1"><span class="c0">When a ray hits an object with this reflective material, the raytracer must calculate the reflected ray at this point of intersection, in the direction of mirror reflection. This reflected ray can be calculated using the equation:</span></p><p class="c1 c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><img src="images/image13.png"></p><p class="c4 c10"><span class="c0">&nbsp; &nbsp;</span><img height="256" src="images/image33.jpg" width="256"></p><p class="c1"><span class="c0">where </span><img src="images/image14.png"><span class="c0">is the incident ray, </span><img src="images/image09.png"><span class="c0">&nbsp; is the reflected ray, and </span><img src="images/image15.png"><span class="c0">&nbsp;is the normal to the surface</span><span class="c0">.</span></p><p class="c6"><span class="c0">[Mirror Reflection, Suffern, 2007]</span></p><p class="c10"><span class="c0">&nbsp; </span></p><p class="c6"><span class="c8 c0">5.3 Glossy Reflections</span></p><p class="c1"><span class="c0">To calculate glossy reflections, I used a similar approach as I did for mirror reflections. In this case, to simulate glossy reflections, we must choose a random direction for the reflected ray instead of using the direction of the mirror reflection. At each point of intersection of a ray with a glossy material, several rays are generated in the direction of the reflected ray, with slightly randomly distorted vector coordinates to create a perturbed effect on the reflected rays. The result is a soft glossy reflective surface.</span></p><p class="c10"><span class="c0">&nbsp; </span></p><p class="c1"><span class="c8 c0">5.4 Depth of Field</span></p><p class="c1"><span class="c0">This was a fairly simple objective. To implement depth of field, I added two extra parameters to the render function call: focal length and aperture size. The simplified camera is made up of a focal point where all the light converges and a projection plane. By starting from the projection point, we can perturb the rays to pass through a deviated point from the optical center, which is the aperture size. The larger the aperture size, the bigger the deviation can be. </span><img height="180" src="images/image32.jpg" width="491"></p><p class="c10"><span class="c0">To implement this, at each pixel I sent out several rays with a slightly jittered direction from the original, that still pass through the aperture size specified by the user, using the projection plane length also specified by the user. The more rays are shot per pixel, the better the effect of depth of field will be. Since this computation is very costly, I only shoot a reasonably low number of sample rays. Objects that are too far away or too close will appear unfocused and blurry. Objects right at the focal plane will appear in focus. [A raytracer in C++, Codermind]</span></p><p class="c10"><span class="c0">&nbsp; </span></p><p class="c6"><span class="c8 c0">5.5 Anti-Aliasing</span></p><p class="c1"><span class="c0">In order to improve quality of the final image and the speed at which this quality is achieved, I have implemented Adaptive Anti Aliasing. This is using a similar approach as I used for SuperSampling for A4. However, to reduce the number of rays sent, I first render the scene with one primary ray per pixel. Once the image is rendered, every (x,y) coordinate of the image is examined and compared against its eight neighbours with a specified threshold value. If this pixel is greater than its neighbouring pixels by a value larger than the threshold, it gets added to a vector of coordinates that will have to be re-rendered using the SuperSampling technique - shooting 16 primary rays and taking their averaged colour. This proved to be a great speed enhancement, as the number of pixels got reduced significantly.</span></p><p class="c10"><span class="c0">&nbsp; </span></p><p class="c1"><span class="c8 c0">5.6 Refraction &nbsp;</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">This proved to be one of the harder objectives.</span></p><p class="c1"><span class="c0">To implement this feature, I extended the </span><span class="c0 c7">LUA</span><span class="c0">&nbsp;material with a refraction coefficient. It is used much like the reflection material:</span></p><p class="c4 c10"><span class="c0 c7">gr.material( &lt;diffuse&gt;, &lt;specular&gt;, &lt; reflection coefficient, refraction coefficient, refraction index&gt;, shininess, glossy reflection)</span></p><p class="c1"><span class="c0">Where in order to get a good refracted &nbsp;material, you must set the refraction coefficient to a value greater than 0 and less than one and provide a realistic refraction coefficient. Clear or transparent materials have a black colour.</span></p><p class="c1"><span class="c0">I Implemented this using Snell&#39;s Law of refraction: </span></p><p class="c1 c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><img src="images/image16.png"></p><p class="c6"><span class="c0">Where &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><img src="images/image17.png"></p><p class="c6"><img src="images/image18.png"><span class="c0">&nbsp; is the inverse ray direction and </span><img src="images/image15.png"><span class="c0">&nbsp;is the surface normal.</span></p><p class="c1"><span class="c0">In general, </span><img src="images/image19.png"><span class="c0">&nbsp;is assumed to be 1 since we generally start with the ray travelling through air. &nbsp;</span><img src="images/image20.png"><span class="c0">is the specified </span><span class="c0 c7">refraction index</span><span class="c0">&nbsp;of the material, and the two indexes are flipped when the ray travels from one material to another. [Surface Physics and Refraction, Suffern, pg 564-571]</span></p><p class="c1"><span class="c0">I also used Beer&#39;s Law to create the transparency and absorbance factors using the following simplified formula:</span></p><p class="c1"><img src="images/image21.png"></p><p class="c10"><span class="c0">&nbsp; &nbsp;</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">Where </span><img src="images/image22.png"><span class="c0">&nbsp;</span><span class="c0">is the path length, and </span><img src="images/image23.png"><span class="c0">&nbsp;is the constant indicating the density of the matter.</span></p><p class="c10"><span class="c0">&nbsp; </span></p><p class="c6"><span class="c8 c0">5.7 Grid Space Subdivision</span></p><p class="c1"><span class="c0">To improve the efficiency of the Raytracer, I have decided to implement Voxels. Based on the number of Voxels defined in </span><span class="c0 c7">a4.hpp</span><span class="c0">, I create a 3D grid with equally sized voxels that contains all the primitives. To see which object is in which voxel, I implemented Axis Aligned Bounding Boxes for each primitive that aligned with the coordinates of the voxels. This significantly increases the speed for object-ray intersection since the first intersection test is always done with the object&#39;s AABB, rather than the actual primitive, since intersecting with the axis-aligned cube is a significantly cheaper calculation. When all the objects are in place inside the grid, I start the ray tracing algorithm with the newly created grid and the list of geometry nodes. For each ray, I trace the ray along its direction through this 3D grid.</span><img height="219" src="images/image34.png" width="483"></p><p class="c1"><span class="c0">To determine which voxel the ray travels through, I used the algorithm described in [A Fast Voxel Traversal Algorithm, John Amanatides]. Once I determine which voxel the ray is in, I check to see if the voxel is empty. If it is not, I check to see if the ray intersects with any AABBs of primitives. I then get the closest point of intersection, and move on to the next voxel. Moving on to the next voxel is required to make sure the point of intersection the ray found in a current voxel was indeed the closest one. Since some objects may pan across several voxels, it is necessary to check all the voxels the ray goes through. To solve the multiple intersection problem, I added a rayID component to my ray structure. Every ray shot, will have a unique value for the rayID, and a global counter keeps track of the current ray ID in order to assign them uniquely. Each object also has the ID of the ray that was tested for intersection most recently. On intersection, the rayID of the ray is compared against the rayID of the object. If they are equal, this intersection test is redundant since the object has previously been tested with the same ray. Otherwise we must perform a ray-object intersection and set the object&#39;s rayID to the current rayID.</span></p><p class="c1"><span class="c0">This implementation yielded outstanding speed improvements</span></p><p class="c1 c12"><span class="c0"></span></p><a href="#" name="aa69ac29a252ef789c7896c01da2530327f33298"></a><a href="#" name="0"></a><table cellpadding="0" cellspacing="0" class="c25"><tbody><tr><td class="c21"><p class="c4 c10 c18"><span class="c8 c2 c0">option</span></p></td><td class="c22"><p class="c4 c10 c18"><span class="c8 c2 c0">voxel</span></p></td><td class="c23"><p class="c4 c10 c18"><span class="c8 c2 c0">objects</span></p></td><td class="c24"><p class="c4 c10 c18"><span class="c8 c2 c0">time (seconds)</span></p></td></tr><tr><td class="c21"><p class="c4 c10 c18"><span class="c0">regular</span></p></td><td class="c22"><p class="c4 c10 c18"><span class="c0">1</span></p></td><td class="c23"><p class="c4 c10 c18"><span class="c0">125</span></p></td><td class="c24"><p class="c4 c10 c18"><span class="c0">11.14</span></p></td></tr><tr><td class="c21"><p class="c4 c10 c18"><span class="c0">no RayID</span></p></td><td class="c22"><p class="c4 c10 c18"><span class="c0">20</span></p></td><td class="c23"><p class="c4 c10 c18"><span class="c0">125</span></p></td><td class="c24"><p class="c4 c10 c18"><span class="c0">0.52</span></p></td></tr><tr><td class="c21"><p class="c4 c10 c18"><span class="c0">Ray ID</span></p></td><td class="c22"><p class="c4 c10 c18"><span class="c0">20</span></p></td><td class="c23"><p class="c4 c10 c18"><span class="c0">125</span></p></td><td class="c24"><p class="c4 c10 c18"><span class="c0">0.492</span></p></td></tr><tr><td class="c21"><p class="c4 c10 c18"><span class="c0">regular</span></p></td><td class="c22"><p class="c4 c10 c18"><span class="c0">1</span></p></td><td class="c23"><p class="c4 c10 c18"><span class="c0">1000</span></p></td><td class="c24"><p class="c4 c10 c18"><span class="c0">141.292</span></p></td></tr><tr><td class="c21"><p class="c4 c10 c18"><span class="c0">no rayID</span></p></td><td class="c22"><p class="c4 c10 c18"><span class="c0">20</span></p></td><td class="c23"><p class="c4 c10 c18"><span class="c0">1000</span></p></td><td class="c24"><p class="c4 c10 c18"><span class="c0">3.36</span></p></td></tr><tr><td class="c21"><p class="c4 c10 c18"><span class="c0">using ray ID</span></p></td><td class="c22"><p class="c4 c10 c18"><span class="c0">20</span></p></td><td class="c23"><p class="c4 c10 c18"><span class="c0">1000</span></p></td><td class="c24"><p class="c4 c10 c18"><span class="c0">2.93</span></p></td></tr></tbody></table><p class="c3"><span class="c0"></span></p><p class="c1"><span class="c0">It is very clear to see how much improvement voxel space subdivision has added to the code. In the first run with 125 objects in the scene, the time for voxel space subdivision with ray ID&#39;s took only 4</span><span class="c0">\</span><span class="c0">% of the time that it took the regular algorithm to render. Using even more objects - 1000 spheres - the improved algorithm only used 2</span><span class="c0">\</span><span class="c0">% of the time.</span></p><p class="c10"><span class="c0">&nbsp; </span></p><p class="c6"><span class="c8 c0">5.8 Soft Shadows</span></p><p class="c1"><span class="c0">To generate soft shadows, I had to extend the </span><span class="c0 c7">LUA</span><span class="c0">&nbsp;language light command to have an area light toggle and radius. To create an area light, invoke the following command in the </span><span class="c0 c7">LUA</span></p><p class="c4 c10"><span class="c0 c7">gr.light(&lt;position&gt;,&lt;colour&gt;,&lt;attenuation&gt;,radius,type)</span></p><p class="c4 c10"><span class="c0">&nbsp; </span><span class="c0">To create an area light, set the type parameter to 1. 0 is used for regular point lights.</span></p><p class="c1"><span class="c0">In order for soft shadows to work, an area light is used to generate a realistic umbra and penumbra of a shadow. To determine how much light an area light casts on a given object, we need to calculate how much of the area light is visible from the point of intersection. To implement this, I generated a large number of rays from the point of intersection towards the light source and averaged out the results, similar to the way I calculated depth of field. To create a more realistic effect, I added a jitter to the ray that was within the bounds of the area light&#39;s radius.</span></p><p class="c10"><span class="c0">&nbsp; &nbsp;</span></p><p class="c6"><span class="c8 c0">5.9 Texture Mapping</span></p><p class="c1"><span class="c0">To implement texture mapping, I added an extra &nbsp;</span><span class="c0 c7">LUA</span><span class="c0">&nbsp;command, that can be used as follows:</span></p><p class="c4 c10"><span class="c0 c7">geoNode:set</span><span class="c0 c7">_texture</span><span class="c0 c7">(&lt;filename&gt;)</span></p><p class="c1"><span class="c0">This will set the geoNode&#39;s texture to the texture contained in filename. I implemented Texture mapping for cubes, spheres and meshes. To determine the UV coordinates of the cube, I used the algorithm described in &quot;A Raytracer in C++&quot;, by the Codermind team. Texture mapping for spheres was also very simple. V is the latitude of the point of intersection and U is the longtitude of the point on the sphere. To get the UV coordinates, we must find the two unit-length vectors </span><img src="images/image24.png"><span class="c0">and </span><img src="images/image25.png"><span class="c0">&nbsp;and which point from the center of the sphere to the top, and a point on the equator.</span><img height="242" src="images/image35.png" width="527"></p><p class="c1"><span class="c0">Next, we must find the unit-length vector </span><img src="images/image26.png"><span class="c0">, that goes from the center of the sphere to the point of intersection. The latitude is the angle between the two vectors </span><img src="images/image26.png"><span class="c0">&nbsp;and </span><img src="images/image24.png"><span class="c0">. </span><span class="c0">To calculate the angle, I used the formula</span></p><p class="c1 c4"><img src="images/image27.png"><span class="c0">, where </span><img src="images/image28.png"></p><p class="c1 c4"><img src="images/image29.png"></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Then we only need to check what side of the sphere the point is in.</span></p><p class="c3"><span class="c0"></span></p><p class="c1"><span class="c0">To create textures for meshes, I had to extend the </span><span class="c0 c7">scene</span><span class="c0 c7">_lua.cpp</span><span class="c0 c7">&nbsp;</span><span class="c0">to accept a third parameter in the call to mesh: </span><span class="c0 c7">gr.mesh(&lt;points&gt;,&lt;uv coordinates&gt;,&lt;faces&gt;) </span><span class="c0">. This allowed me to import</span><span class="c0 c7">&nbsp;.OBJ </span><span class="c0">files from Houdini that contained the UV coordinates so that I could use texture mapping for the Wall-E model. For mesh triangle-to-triangle mapping to work, I had to interpolate the UV texture coordinates, using the standard Barycentric method from class. For any given triangle with vertices </span><img src="images/image30.png"><span class="c0">&nbsp;</span><span class="c0">, </span><span class="c0">the area is computed as follows:</span></p><p class="c1 c4"><img src="images/image31.png"></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span class="c8 c0">5.10 Final Scene</span></p><p class="c1"><span class="c0">The final scene was quite the adventure to create. I originally modeled Wall-E in Maya and then entered the coordinates of the primitives into the LUA file based on the coordinates I had in Maya. I then exported the tire and eye meshes from Maya as </span><span class="c0 c7">.OBJ </span><span class="c0">files and imported them into the LUA scene. I also created matching textures and normal maps for the meshes. Once the LUA file was ready and I tried rendering, I realized that the UV coordinates that Maya generates, do not match up with the LUA coordinate system. I then had to import the whole scene into Houdini and regenerate the coordinates in order to get the right UV vertices. After many tries, I finally got the LUA scene set up properly, and just the way I wanted it in Maya. </span></p><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c8 c0 c19">6 Extra Objectives</span></p><p class="c3"><span class="c0"></span></p><p class="c6"><span class="c8 c0">6.1 Extra Objective: </span><span class="c0">Environment Mapping</span></p><p class="c1"><span class="c0">I really wanted to have a backdrop of the galaxy behind Wall-E, since it is one of the key elements of the movie. Since I already had the code for determining the UV coordinate of a texture on a cube, it was really simple to implement the code for environment mapping. </span></p><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c6"><span class="c8 c0">6.2 Extra Objective: </span><span class="c0">Normal Mapping</span></p><p class="c1"><span class="c0">I only found out about normal mapping a few days before the deadline of this project, and got really interested in how it works. I used this technique to create the illusion of tire texture and moon craters in the scene. To calculate the diffuse colour of a surface, we take the dot product of the vector from the point of intersection to the light source and the unit normal to the surface at that point. The result is the intensity of the light on that surface - that is, we multiply the R component of the material&#39;s colour by the tangent to the surface, the G component of the material&#39;s colour by the cross product of the normal and and tangent, and the B component by the normal. This will give a really interesting effect of &quot;bumps&quot; on a texture.</span></p><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c8 c0 c19">7 Wrap Up</span></p><p class="c10"><span class="c0">After having implemented an extended Raytracer, i finally understand most of what is going on during ray tracing. I found everything very fascinating, and really wish I had more time to implement other objectives. If I had &nbsp;more time to spend on the project, I would improve the user - input part of my project, since I did not have much time to spend on creating user variables. I really wanted to get as many objectives done as possible and overlooked a lot of handy user-input functionality and command line arguments. This is one project I will definitely come back to, to extend even further now that I have a good understanding of the algorithm.</span></p><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c8 c0 c19">8 Bibliography</span></p><ol class="c20" start="1"><li class="c1 c14"><span class="c0">Alan Watt and Mark Watt: Advanced Animation and Rendering Techniques, Theory and Practice, ACM Press, 1992, pg 241-248 [performance enhancing algorithms], pg 262-265 [distributed raytracing, used for Depth of Field and soft shadows]</span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="2"><li class="c1 c14"><span class="c0">B. Peroche and H. Rushmeier, Rendering Techniques 2000, SpringerComputerScience, Springer-Verlag/Wien, 2000, pg 269-279 [soft shadow maps for linear lights]</span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="3"><li class="c1 c14"><span class="c0">Donald Hearn amd M.Pauline Baker, Computer Graphics, Second Edition, Prentice Hall, 1994, pg 535-562 [space-subdivision models, antialiasing, distributed ray tracing, texture and environmental mapping]</span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="4"><li class="c1 c14"><span class="c0">Peter Shirley, Fundamentals of Computer Graphics, A K Peters, Ltd, 2005, pg 213-255 [refraction, spatial partitioning, distribution ray tracing (antialiasing, soft shadows, depth of field and glossy reflections), texture mapping</span></li><li class="c1 c14"><span class="c0">James Arvo, Graphics Gems II, Academic Press, 1995, pg 264-266 [Voxel based raytracing - improving efficiency using partitioning]</span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="6"><li class="c1 c14"><span class="c0">Ray Tracer, Distributed Ray Tracing (Soft Shadow),<br></span><span class="c2 c0"><a class="c15" href="http://ray-tracer-concept.blogspot.ca/2011/12/distributed-ray-tracing-soft-shadow.html">http://ray-tracer-concept.blogspot.ca/2011/12/distributed-ray-tracing-soft-shadow.html</a></span><span class="c0">&nbsp;</span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="7"><li class="c1 c14"><span class="c0">Raytracing Topic and Techniques, Jacco Bikker<br></span><span class="c2 c0"><a class="c15" href="http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_1_Introduction.shtml">http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_1_Introduction.shtml</a></span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="8"><li class="c1 c14"><span class="c0">A Raytracer in C++, Codermind,<br></span><span class="c2 c0"><a class="c15" href="http://www.codermind.com/articles/Raytracer-in-C++-Introduction-What-is-ray-tracing.html">http://www.codermind.com/articles/Raytracer-in-C++-Introduction-What-is-ray-tracing.html</a></span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="9"><li class="c1 c14"><span class="c0">Fast Ray Tracing Techniques, John A. Tsakook,<br></span><span class="c2 c0"><a class="c15" href="http://uwspace.uwaterloo.ca/bitstream/10012/3947/1/thesis.pdf">http://uwspace.uwaterloo.ca/bitstream/10012/3947/1/thesis.pdf</a></span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="10"><li class="c1 c14"><span class="c0">Ralistic Ray Tracing, Second edition, Shirley and Morley, A K Peters Ltd, 2003</span></li></ol><p class="c3"><span class="c0"></span></p><ol class="c20" start="1"><li class="c1 c14"><span class="c0">Ray Tracing from the Ground Up, Kevin Suffern, A K PEters Ltd, 2003</span></li></ol><p class="c10"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c8 c0 c19">9 </span><span class="c8 c0 c19">Objectives</span></p><p class="c10"><span class="c0">Full UserID:</span><span class="c0">______________________ </span><span class="c0">Student ID:</span><span class="c0">___________________________</span></p><p class="c10"><span class="c0">Date:___________________________</span></p><p class="c3"><span class="c0"></span></p><ol class="c27" start="1"><li class="c1 c14"><span class="c8 c0">Reflections</span><span class="c0">: possible to add mirror reflection to primitives.<br></span></li><li class="c1 c14"><span class="c8 c0">Soft Shadows:</span><span class="c0">&nbsp;Shadows appear realistically soft<br></span></li><li class="c1 c14"><span class="c8 c0">Texture Mapping: </span><span class="c0">a texture material can be added to a geometry node in a LUA file, and <br>texture mapped primitives are rendered correctly<br></span></li><li class="c1 c14"><span class="c8 c0">Glossy reflections:</span><span class="c0">&nbsp;a glossiness factor can be added to a material in the LUA file and can be used to create glossy reflections<br></span></li><li class="c1 c14"><span class="c8 c0">Extra Primitives:</span><span class="c0">&nbsp;Extra primitives such as cones and cylinders can be added to the scene and rendered properly.<br></span></li><li class="c1 c14"><span class="c8 c0">Depth of Field: </span><span class="c0">Areas in the center of the viewing range appear in focus, while objects that are too close or too far away appear blurred. <br></span></li><li class="c1 c14"><span class="c8 c0">Anti-Aliasing using Adaptive Sampling </span><span class="c0">or Jittering: possible to tell the difference between image quality with and without anti-aliasing. Renders using anti-aliasing appear smoother and cleaner, while renders without anti-aliasing appear to have jagged lines.<br></span></li><li class="c1 c14"><span class="c8 c0">Refraction: </span><span class="c0">Refractive surfaces render correctly<br></span></li><li class="c1 c14"><span class="c8 c0">Algorithm improvement using grid space subdivision: </span><span class="c0">Clear performance improvement.</span><span class="c0"><br></span></li><li class="c1 c14"><span class="c8 c0">Final Scene: </span><span class="c0">a scene is created in a lua file using the LUA modeling language. </span></li></ol><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c10"><span class="c0">Signature:____________________________________</span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p><p class="c3"><span class="c0"></span></p></div></div></body></html>
